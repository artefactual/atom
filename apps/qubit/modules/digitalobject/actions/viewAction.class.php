<?php

/*
 * This file is part of the Access to Memory (AtoM) software.
 *
 * Access to Memory (AtoM) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Access to Memory (AtoM) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Access to Memory (AtoM).  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Digital Object view action
 *
 * @package    AccesstoMemory
 * @subpackage digital object
 * @author     Andy Koch <koch.andy@gmail.com>
 */
class DigitalObjectViewAction extends sfAction
{
  public function execute($request)
  {
    $pathinfo = pathinfo($request->getPathInfo());
    $pathinfo['dirname'] = str_replace("/{$request->module}/{$request->action}", '', $pathinfo['dirname']).'/';

    $this->resource = QubitDigitalObject::getByPathFile($pathinfo['dirname'], $pathinfo['basename']);

    // We are going to need this later
    $this->digitalObjectId = $this->resource->id;

    // Resource Found?
    if (null === $this->resource)
    {
      $this->forward404();
    }

    list($infoObj, $action) = $this->getInfoObjAndAction();

    // Do appropriate ACL check(s). Master copy of text objects are always allowed for reading
    if ((!QubitAcl::check($infoObj, $action) || !QubitGrantedRight::checkPremis($infoObj->id, $action))
      && !($action == 'readMaster' && $this->resource->mediaTypeId == QubitTerm::TEXT_ID))
    {
      $this->forward404();
    }

    if ($this->needsPopup($action))
    {
      $this->resource = $this->resource->informationObject;

      # Generate a safe random string specific to this user and digital object.
      # The string (token) is stored in the user session and included in the
      # copyright statement form so we enable the user to include the token when
      # the object is requested. needsPopup() compares the token previously
      # generated by random_bytes with the one provided in the request.
      # We are using random_compat to safely generate random strings in PHP 5.6
      # or older. See #10154.
      # Using require_once because I can't load random_compat from autoload.yml.
      require_once sfConfig::get('sf_root_dir').'/vendor/random_compat/random.php';
      $this->accessToken = bin2hex(random_bytes(32)); # URL friendly
      $this->context->user->setAttribute("token-$this->digitalObjectId", $this->accessToken, 'symfony/user/sfUser/copyrightStatementTmpAccess');

      $this->response->addMeta('robots', 'noindex,nofollow');
      $this->setTemplate('viewCopyrightStatement');

      $this->copyrightStatement = sfConfig::get('app_digitalobject_copyright_statement');

      return sfView::SUCCESS;
    }

    $this->setResponseHeaders();

    return sfView::HEADER_ONLY;
  }

  protected function needsPopup($action)
  {
    // Only if the user is reading the master digital object
    if ($action !== 'readMaster')
    {
      return false;
    }

    // Only if the copyright statement is enabled
    if ('1' !== sfConfig::get('app_digitalobject_copyright_statement_enabled', false))
    {
      return false;
    }

    // Check if there is any right statement associated with the object where
    // the basis = copyright and the restriction = conditional (regardless of
    // the Rights Act). We don't need to show the popup otherwise.
    $sql = 'SELECT EXISTS(
      SELECT 1
        FROM '.QubitInformationObject::TABLE_NAME.' io
        JOIN '.QubitRelation::TABLE_NAME.' rel ON (rel.subject_id = io.id)
        JOIN '.QubitGrantedRight::TABLE_NAME.' gr ON (rel.object_id = gr.rights_id)
        JOIN '.QubitRights::TABLE_NAME.' r ON (gr.rights_id = r.id)
      WHERE
        io.id = ? AND
        rel.type_id = ? AND
        gr.restriction = ? AND
        r.basis_id = ?
      LIMIT 1) AS has';
    $r = QubitPdo::fetchOne($sql, array(
      $this->resource->informationObject->id,
      QubitTerm::RIGHT_ID,
      QubitGrantedRight::CONDITIONAL_RIGHT,
      QubitTerm::RIGHT_BASIS_COPYRIGHT_ID));

    if (false === $r || !isset($r->has))
    {
      throw new sfException('Unexpected error');
    }
    if ('1' !== $r->has)
    {
      return false;
    }

    return false === $this->isAccessTokenValid();
  }

  protected function setResponseHeaders()
  {
    $this->response->setContentType($this->resource->mimeType);

    // Using X-Accel-Redirect (Nginx) unless ATOM_XSENDFILE is set
    if (false === filter_var($_SERVER['ATOM_XSENDFILE'], FILTER_VALIDATE_BOOLEAN))
    {
      $this->response->setHttpHeader('X-Accel-Redirect', '/private'.$this->resource->getFullPath());
    }
    else
    {
      $this->response->setHttpHeader('X-Sendfile', sprintf('%s/%s',
        sfConfig::get('sf_root_dir'),
        $this->resource->getFullPath()));
    }
  }

  private function getInfoObjAndAction()
  {
    switch ($this->resource->usageId)
    {
      case QubitTerm::MASTER_ID:
        $action = 'readMaster';
        $infoObj = $this->resource->informationObject;
        break;

      case QubitTerm::REFERENCE_ID:
        $action = 'readReference';
        $infoObj = $this->resource->parent->informationObject;
        break;

      case QubitTerm::THUMBNAIL_ID:
        $action = 'readThumbnail';
        $infoObj = $this->resource->parent->informationObject;
        break;

      default:
        throw new sfException("Invalid usageId given in digitalobject/view: {$this->resource->usageId}");
    }

    return array($infoObj, $action);
  }

  private function isAccessTokenValid()
  {
    $providedToken = $this->request->token;
    $internalToken = $this->context->user->getAttribute("token-$this->digitalObjectId", null, 'symfony/user/sfUser/copyrightStatementTmpAccess');

    if (empty($providedToken) || empty($internalToken))
    {
      return false;
    }

    if ($providedToken !== $internalToken)
    {
      return false;
    }

    return true;
  }
}
